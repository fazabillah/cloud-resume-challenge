[
  {
    "slug": "cloud-resume-mirror-architecture",
    "title": "My Cloud Resume Challenge: Building a Mirror Architecture on AWS and Azure",
    "excerpt": "A dual-platform strategy for comparative learning, building the same serverless system on both AWS and Azure to understand how two cloud giants solve the same problems.",
    "author": "Faza Billah",
    "publishedDate": "Jan 2026",
    "readTime": "8 min read",
    "tags": [
      "Cloud Engineer",
      "AWS",
      "Azure",
      "Serverless"
    ],
    "coverImage": null,
    "body_html": "<h2>1. Introduction: Zero to... Two Clouds?</h2>\n<p>Starting from zero, my goal wasn't just to learn theory but to build practical, in-demand skills that could be immediately applied. The \"Cloud Resume Challenge\" presented itself as the perfect framework for this, offering a structured path to building a complete serverless application. I decided to add a personal twist: instead of choosing one cloud provider, I would build the entire system simultaneously on both AWS and Azure. I call this dual-platform strategy the \"Mirror Architecture.\" It's a method designed for comparative learning, allowing me to see exactly how two of the biggest players in the cloud space approach and solve the same set of problems, service by service. This project was never about just hosting a simple static resume; the true scope was to engineer and deploy a full-stack, automated system on two parallel cloud infrastructures.</p>\n<h2>2. The Real Goal: It's a System, Not Just a Site</h2>\n<p>The true value of this project isn't in hosting a few HTML and CSS files. it's in building a complete, dynamic, serverless application. A static site is simple, but a system requires a backend, a database, and automation. This challenge pushes me to assemble these moving parts into a cohesive whole, which is where the real learning happens. The key components that elevate this project from a webpage to a full-fledged system include:</p>\n<ul>\n<li><strong>A real database:</strong> The system uses NoSQL databases. Amazon DynamoDB on the AWS side and Azure CosmosDB on the Azure side to store and retrieve dynamic data, such as a live visitor counter displayed on the resume.</li>\n<li><strong>An API layer:</strong> To connect the frontend website to the database, a serverless API layer was built. This consists of an API Gateway that routes requests to a compute function (AWS Lambda or Azure Functions) which, in turn, interacts with the database. This provides a secure and scalable backend endpoint for the frontend to call.</li>\n<li><strong>Automation:</strong> A professional cloud setup relies heavily on automation. This project incorporates Infrastructure as Code (IaC) to define and manage cloud resources programmatically (using AWS CloudFormation and Terraform) and a CI/CD pipeline (using GitHub Actions) to automate testing and deployment for both cloud environments. To build such a system effectively across two distinct cloud platforms, I first need a clear architectural map to guide the way.</li>\n</ul>\n<h2>3. The High-Level Map: A Side-by-Side Look at AWS vs. Azure</h2>\n<p>The \"Mirror Architecture\" provides a practical, side-by-side comparison of how AWS and Azure handle the fundamental layers of a modern web application. By breaking down the architecture into its core functional layers, I can see a direct translation of services and concepts between the two ecosystems.</p>\n<h3>3.1 The Front Door: DNS</h3>\n<p>This layer translates a human-readable domain name (like example.com) into a machine-readable IP address that a browser can use to locate the server.</p>\n<p>| AWS Stack | Azure Stack |\n| ------ | ------ |\n| Route 53 (fazabillah.com) | Cloudflare (fazabillah.my) |</p>\n<h3>3.2 Content Delivery: CDN &amp; Static Storage</h3>\n<p>This layer is responsible for storing the static website files (HTML, CSS, JavaScript) and using a Content Delivery Network (CDN) to distribute them globally for faster load times. In the Azure stack, Azure Storage holds the files, Azure CDN distributes them, and Cloudflare provides DNS and SSL.</p>\n<p>| AWS Stack | Azure Stack |\n| ------ | ------ |\n| S3 + CloudFront | Azure Storage + Azure CDN + Cloudflare |</p>\n<h3>3.3 The Brains: API &amp; Compute Logic</h3>\n<p>This is the serverless backend, which runs application code in response to API requests—such as fetching and updating the visitor count—without the need to provision or manage servers.</p>\n<p>| AWS Stack | Azure Stack |\n| ------ | ------ |\n| API Gateway + Lambda | Azure Functions |</p>\n<h3>3.4 The Memory: Database</h3>\n<p>This layer provides the persistent storage for application data. In this case, it's a simple but crucial NoSQL database used to store the site's visitor count.</p>\n<p>| AWS Stack | Azure Stack |\n| ------ | ------ |\n| DynamoDB | CosmosDB |</p>\n<p>With the cloud infrastructure mapped out, the next step is to look at the code and tools used to build, define, and deploy this entire system.</p>\n<h2>4. The Code and Tooling Under the Hood</h2>\n<p>The cloud services provide the foundation, but the implementation is brought to life through a modern frontend, Infrastructure as Code (IaC) for resource management, and automated deployment pipelines for seamless updates. The choice of IaC tools was tailored to each platform's ecosystem:</p>\n<ul>\n<li><strong>AWS:</strong> The infrastructure was defined using <strong>AWS CloudFormation</strong> along with the <strong>Serverless Application Model (SAM)</strong>, a framework that simplifies building serverless applications. This was complemented by <strong>Ansible</strong> for configuration management tasks, automating parts of the setup not covered by the IaC templates—a practical approach showing how different tools can solve different automation problems.</li>\n<li><strong>Azure:</strong> For the Azure stack, <strong>Terraform</strong> was used. Its provider ecosystem makes it a powerful choice for managing resources in a multi-cloud or platform-agnostic way.</li>\n</ul>\n<p>The frontend is a modern <strong>React 19 Single-Page Application (SPA)</strong> built with <strong>Vite</strong>. It uses <strong>React Router 7</strong> for navigation and is styled with <strong>Bootstrap 4.5</strong>, creating a responsive and structured user interface.</p>\n<p>Connecting everything together is <strong>GitHub Actions</strong>, which serves as the single, unifying CI/CD tool. It automates the entire deployment process for both the AWS and Azure environments, ensuring that any changes to the code or infrastructure are deployed consistently and reliably.</p>\n<h2>5. Final Thoughts: Was Building Two Clouds Worth It?</h2>\n<p>So, was tackling two cloud platforms from a standing start worth the extra effort? Absolutely. The \"Mirror Architecture\" approach was an incredible learning accelerator. Instead of just learning <em>how</em> to do something on AWS, I was forced to understand <em>why</em> I was doing it, as I had to immediately translate that concept to its Azure equivalent. It solidifies core cloud principles far more effectively than sticking to a single ecosystem.</p>\n<p>The single most important lesson from this comparative build is that while the service names and implementation details differ, the fundamental architectural patterns; DNS, CDN, serverless compute, NoSQL databases are universal. Learning them this way provides a robust, provider-agnostic understanding of modern cloud infrastructure.</p>\n<p>For anyone starting out, I highly recommend this dual-build approach. It's challenging, but the clarity you gain is invaluable. And from a practical standpoint, it's surprisingly affordable. Here is the final annual cost breakdown for the project:</p>\n<ul>\n<li><strong>AWS Cost:</strong> ~$6/year (due to the $0.50/mo for a Route 53 hosted zone)</li>\n<li><strong>Azure Cost:</strong> ~$0/year (leveraging the free tier)</li>\n<li><strong>Domain:</strong> ~$12/year</li>\n</ul>"
  }
]